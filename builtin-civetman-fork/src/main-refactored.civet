// --------------------------------------------------------------
// main-refactored.civet – Experimental rewrite with clean layering
// --------------------------------------------------------------

// ──────────────────────────────────────────────────────────────
// Imports (pure-logic modules come first – no UI side-effects)  
// ──────────────────────────────────────────────────────────────

c from "picocolors"
{ program } from "commander"
fs from "fs-extra"
glob from "fast-glob"
{ join } from "node:path"
path from "node:path"
os from "node:os"
crypto from "node:crypto"
chokidar from "chokidar"
ora from "ora"
{ compile } from "@danielx/civet"
{ parseTree as jsoncParseTree, findNodeAtLocation as jsoncFindNodeAtLocation, getNodeValue as jsoncGetNodeValue, modify as jsoncModify, applyEdits as jsoncApplyEdits } from "jsonc-parser"
{ createRequire } from "node:module"
// @ts-ignore
import { BuildEngine } from "./engine.civet"
import { loadHashesFromJSONL, appendHashToJSONL } from "./jsonl-helpers.civet"

// ------------------------------------------------------------------
// Global build fingerprint – any change forces full rebuilds
// ------------------------------------------------------------------
require := createRequire(import.meta.url)
buildFingerprint := JSON.stringify({
    civetmanVersion: "0.1.0", // bump on release
    civetCompilerVersion: require("@danielx/civet/package.json").version,
    nodeMajor: process.version.split(".")[0]
})

// ──────────────────────────────────────────────────────────────
// Types & defaults                                                
// ──────────────────────────────────────────────────────────────

type Options =
    tsx: boolean,
    gitIgnore: boolean,
    vscodeHide: boolean,
    inlineMap: "full" | "fileurl" | "none",
    mapFiles: boolean,
    outTs?: string[],      // folders
    outTsx?: string[],
    concurrency?: number,
    forcePolling?: boolean

type CompileSuccess = {
    status: "built" | "skip",
    file: string,
    outFile: string,
    signature: string
}
type CompileError = {
    status: "error",
    file: string,
    error: any
}
export type CompileResult = CompileSuccess | CompileError

defaultOpts: Options :=
    tsx: false,
    gitIgnore: true,
    vscodeHide: true,
    inlineMap: "full",
    mapFiles: false,
    concurrency: Math.min(2, (os.cpus()?.length || 2)),
    forcePolling: false

// ──────────────────────────────────────────────────────────────
// Build-state layer – Pure functions operating on BuildContext  
// ──────────────────────────────────────────────────────────────

// A central object that holds all mutable state. Tests can mock it easily.
export type BuildContext =
    opts: Options,
    cwd: string,
    // list of civet source files (fixed for single build run)
    sources: string[],
    // outputs produced in this run
    outFiles: Set<string>,
    // previous manifest data (for pruning)
    prevGenerated: Set<string>,
    // previous content hashes for incremental builds
    prevHashes: Record<string, { sig: string, outFile: string }>,
    // new hashes produced this run
    newHashes: Record<string, { sig: string, outFile: string }>

// ---------------- helper utils (pure) ----------------

computeHash := (input: string): string =>
    crypto.createHash("sha1").update(input).digest("hex")

// ---------------- debug ----------------
// Debug logging – enable by setting CIVETMAN_DEBUG env var.
//   CIVETMAN_DEBUG="*"     → log every category
//   CIVETMAN_DEBUG="WATCHER,COMPILE" → log only those containing this substring (case-insensitive)

debugEnv := process.env.CIVETMAN_DEBUG
outputDebug := !!debugEnv
debugFilters := if debugEnv? and debugEnv != "*" and debugEnv.toLowerCase() != "all"
    new Set(debugEnv.split(",").map((s: string) => s.trim().toUpperCase()).filter((s) => !!s))
else
    null

logDebug := (...args: any[]) =>
    if !outputDebug return
    tag := typeof args[0] == "string" ? args[0].toUpperCase() : ""
    if debugFilters? and ![...debugFilters].some((f) => tag.includes(f))
        return
    console.log("[civetman-debug]", ...args)

// ------------------------------------------------------------------
// Atomic write utility ensures we never leave partially-written files
// ------------------------------------------------------------------
safeWrite := async (filePath: string, data: string | Buffer) =>
    await fs.ensureDir(path.dirname(filePath))
    tmp := filePath + "." + crypto.randomUUID() + ".civetmantmp"
    await fs.writeFile(tmp, data)
    await fs.rename(tmp, filePath)

// Remove stray *.civetmantmp files that belong to our outputs
cleanupTmpFiles := async (cwd: string) =>
    tmpFiles := await glob("**/*.civetmantmp", cwd: cwd)
    for tmp of tmpFiles
        try
            await fs.unlink(tmp)
        catch _
            continue

fileToOutFile := (file: string, tsx: boolean) =>
    file.replace(".civet", tsx ? ".tsx" : ".ts")

// Decide ts vs tsx based on CLI options / folder flags
resolveOutputType := (ctx: { cwd: string, opts: Options }, file: string): boolean =>
    relativeFile := path.relative(ctx.cwd, file)

    findLongestMatch := (dirs: string[]) =>
        matches := (dirs || []).filter((dir: string) => {
            normalized := path.normalize(dir)
            return normalized === '.' || relativeFile.startsWith(normalized + path.sep)
        })
        if !matches.length return null
        matches.sort((a,b) => b.length - a.length)[0]

    tsxMatch := findLongestMatch(ctx.opts.outTsx ? ctx.opts.outTsx : [])
    tsMatch  := findLongestMatch(ctx.opts.outTs  ? ctx.opts.outTs  : [])
    if tsxMatch && tsMatch
        return tsxMatch.length >= tsMatch.length
    if tsxMatch return true
    if tsMatch  return false
    return ctx.opts.tsx

collectDirs := (val: string, prev: string[]) =>
    // Accept comma-separated lists or repeatable flags.
    prev.concat(
        val.split(",")
            .map((s: string) => s.trim())
            .filter((s): s is string => !!s)
    )

// ---------------- manifest helpers (pure fs) ----------------
manifestDir := (cwd: string) => join(cwd, ".civetman")
manifestFile := (cwd: string) => join(manifestDir(cwd), "manifest.json")
hashManifestFile := (cwd: string) => join(manifestDir(cwd), "hashes.jsonl")

loadJSON := async (file: string, fallback: any) =>
    if await fs.exists(file)
        try
            JSON.parse(await fs.readFile(file, "utf8"))
        catch
            fallback
    else
        fallback

saveJSON := async (file: string, data: any) =>
    await fs.ensureDir(path.dirname(file))
    await safeWrite(file, JSON.stringify(data, null, 2))

loadPrevState := async (cwd: string) =>
    manifestObj := await loadJSON(manifestFile(cwd), { generated: [] })
    prevGenerated := new Set(manifestObj.generated as string[])
    prevHashes := await loadHashesFromJSONL(hashManifestFile(cwd))
    return { prevGenerated, prevHashes }

saveNewState := async (ctx: BuildContext) =>
    logDebug("[STATE] Saving new state", { outFiles: [...ctx.outFiles], newHashCount: Object.keys(ctx.newHashes).length })
    
    // Save generated file list (still full write, but it's small)
    await saveJSON(manifestFile(ctx.cwd), { version: 1, generated: [...ctx.outFiles] })

    // Append new hashes to our JSONL file instead of overwriting.
    for (const [file, data] of Object.entries(ctx.newHashes)) {
        await appendHashToJSONL(hashManifestFile(ctx.cwd), { file, ...data })
    }

    logDebug("[STATE] State saved successfully")

// ---------------- compilation (pure, worker-thread ready) ----------------
export compileSource := async (ctx: BuildContext, file: string): Promise<CompileResult> => {
    // decide output type & expected filename
    isTsx := resolveOutputType(ctx, file)
    expectedOut := fileToOutFile(file, isTsx)
    logDebug("[COMPILE] Starting compilation", { file, expectedOut, isTsx })

    // compute deterministic signature for incremental builds ------------
    content := await fs.readFile(file, "utf8")
    signature := computeHash(
        content +
        JSON.stringify({ tsx: isTsx, inlineMap: ctx.opts.inlineMap, mapFiles: ctx.opts.mapFiles }) +
        buildFingerprint
    )

    prev := ctx.prevHashes[file]
    logDebug("[COMPILE] Sig check", { file, signature, prevSig: prev?.sig })

    try
        if prev and prev.sig == signature and prev.outFile == expectedOut and await fs.exists(expectedOut)
            // outputs are guaranteed to be correct – quick skip
            ctx.outFiles.add(expectedOut)
            if ctx.opts.mapFiles and await fs.exists(expectedOut + ".map")
                ctx.outFiles.add(expectedOut + ".map")
            logDebug("[COMPILE] Skipping (signature match)", file)
            return { status: "skip", file, outFile: expectedOut, signature: signature }
    catch _
        logDebug("[COMPILE] Error during sig check", file)
        // fall through to compile on any error
    
    // actual compile
    try
        logDebug("[COMPILE] Starting actual compilation", file)
        { code, sourceMap } := await compile(content, { filename: file, sourceMap: true }) as { code: string, sourceMap: any }
        logDebug("[COMPILE] Compilation successful", file)

        // --- Source-map handling -----------------------------------------
        codeOut .= code
        mapFile := expectedOut + ".map"

        if ctx.opts.inlineMap == "full"
            mapJson := sourceMap.json(file, expectedOut)
            base64Map := Buffer.from(JSON.stringify(mapJson)).toString("base64")
            codeOut += "\n//# sourceMappingURL=data:application/json;base64," + base64Map + "\n"

        if ctx.opts.mapFiles
            mapJson := sourceMap.json(file, expectedOut)
            await safeWrite(mapFile, JSON.stringify(mapJson))
            ctx.outFiles.add(mapFile)

            if ctx.opts.inlineMap == "fileurl"
                codeOut += "\n//# sourceMappingURL=" + path.basename(mapFile) + "\n"

        await safeWrite(expectedOut, codeOut)
        ctx.outFiles.add expectedOut
        logDebug("built", file)
        return { status: "built", file, outFile: expectedOut, signature: signature }
    catch e
        // propagate error – UI layer decides what to log/exit
        throw e
}

// ---------------- side-effect helpers (IDE, gitignore) ----------------
syncIDEConfigs := async (ctx: BuildContext) =>
    await addVscodeExcludes(ctx)
    await addGitignoreEntries(ctx)

addVscodeExcludes := async (ctx: BuildContext) =>
    // Build the list of patterns we should hide inside VS Code
    files := [...ctx.outFiles]
    
    placeholder := "below is generated by civetman"
    configKey := "files.exclude"
    tmpGlob := "**/*.civetmantmp"

    vscodeDir := join(ctx.cwd, ".vscode")
    settingsFile := join(vscodeDir, "settings.json")

    await fs.ensureDir(vscodeDir)
    await fs.ensureFile(settingsFile)

    content := await fs.readFile(settingsFile, "utf8")
    errors := [] as any[]
    tree := jsoncParseTree(content, errors, { allowTrailingComma: true })
    if !tree
        // cannot parse settings, bail early
        return

    node := jsoncFindNodeAtLocation(tree, [configKey])
    existing := (node ? jsoncGetNodeValue(node) : {}) as Record<string, boolean>

    // Preserve any excludes that are not ours
    manual := Object.entries(existing).reduce((acc: Record<string, boolean>, [k,v]) =>
        if k != placeholder && !files.includes(k)
            acc[k] = v
        acc
    , {})

    newExclude := if ctx.opts.vscodeHide
        dynamic := files.reduce((acc: Record<string, boolean>, f: string) => ({ ...acc, [f]: true }), {})
        dynamic[tmpGlob] = true
        { ...manual, [placeholder]: true, ...dynamic }
    else
        manual

    edits := jsoncModify(content, [configKey], newExclude, { formattingOptions: { insertSpaces: true, tabSize: 2 } })
    newContent := jsoncApplyEdits(content, edits)
    if newContent != content
        await fs.writeFile(settingsFile, newContent, "utf8")
    return

addGitignoreEntries := async (ctx: BuildContext) =>
    gitignorePath := join(ctx.cwd, ".gitignore")
    startMarker := "# civetman:start - Managed by civetman. DO NOT EDIT THIS BLOCK."
    endMarker := "# civetman:end - End of civetman managed block."
    civetmanDirEntry := ".civetman/"

    await fs.ensureFile(gitignorePath)
    original := await fs.readFile(gitignorePath, "utf8")
    lines := original.split('\n')

    // Filter out our managed entries, preserving all other lines.
    // This is self-healing if the file was corrupted.
    nonManagedLines := [] as string[]
    inManagedBlock .= false
    for line of lines
        trimmed := line.trim()
        if trimmed == startMarker
            inManagedBlock = true
            continue
        if trimmed == endMarker
            inManagedBlock = false
            continue
        if trimmed == civetmanDirEntry
            continue
        if !inManagedBlock
            nonManagedLines.push(line)

    // Clean up trailing blank lines to prevent them from accumulating
    while nonManagedLines.length > 0 && nonManagedLines[nonManagedLines.length - 1].trim() === ''
        nonManagedLines.pop()
    
    // Create the new managed block, sorted for determinism
    managedBlock := if ctx.opts.gitIgnore
        [startMarker, ...[...ctx.outFiles].sort(), endMarker].join('\n')
    else
        ""

    // Reconstruct the file content
    newContent .= nonManagedLines.join('\n').trimEnd()
    if newContent
        newContent += '\n\n'
    
    // Add the managed block if it exists
    if managedBlock
        newContent += managedBlock + '\n\n'

    // Always ensure the .civetman directory is ignored
    newContent += civetmanDirEntry + '\n'

    if newContent.trim() != original.trim()
        await safeWrite(gitignorePath, newContent)
    return

// ---------------- helper to prune stale outputs ----------------
pruneStaleOutputs := async (ctx: BuildContext) =>
    stale := [...ctx.prevGenerated].filter((f) => !ctx.outFiles.has(f))
    for file of stale
        try
            if await fs.exists(join(ctx.cwd, file))
                await fs.unlink(join(ctx.cwd, file))
        catch _
            // best effort – ignore deletion errors
            continue
    return

// ---------------- top-level build function (pure-ish) ----------------
runBuild := async (cwd: string, opts: Options) =>
    // Step 0: scrub temp files from previous aborted runs
    await cleanupTmpFiles(cwd)

    // Step 1: collect source files
    sources := await glob("**/*.civet", ignore: ["node_modules/**/*", "dist/**/*"], cwd: cwd)

    // Step 2: load previous state and create context
    { prevGenerated, prevHashes } := await loadPrevState(cwd)
    ctx: BuildContext :=
        opts: opts,
        cwd: cwd,
        sources: sources,
        outFiles: new Set<string>(),
        prevGenerated: prevGenerated,
        prevHashes: prevHashes,
        newHashes: {}

    // Create the build engine which orchestrates compilation.
    engine := new BuildEngine(ctx)

    // Step 3: build all, with progress reporting
    spinner := ora(c.blue("Building Civet files")).start()
    hadError .= false
    builtCount .= 0
    skippedCount .= 0

    onProgress := (res: any) => {
        if res.status == 'built'
            spinner.succeed(c.cyan(res.file) + " -> " + c.green(res.outFile))
            ctx.newHashes[res.file] = { sig: res.signature, outFile: res.outFile }
            builtCount++
        else if res.status == 'skip'
            ctx.newHashes[res.file] = { sig: res.signature, outFile: res.outFile }
            skippedCount++
        else if res.status == 'error'
            hadError = true
            spinner.fail(c.red(`Error compiling ${res.file}`))
            console.error(res.error)
    }

    await engine.buildAll(onProgress)
    
    finalMessage .= `Built ${builtCount} file(s)`
    if skippedCount > 0
        finalMessage = `${finalMessage}, ${skippedCount} skipped`

    if !hadError
        spinner.succeed(c.green(`Build complete! ${finalMessage}`))
    else
        spinner.fail(c.red(`Build failed. ${finalMessage}`))

    // Step 4: prune stale outputs & save new state
    await pruneStaleOutputs(ctx)

    await saveNewState(ctx)

    // Step 5: IDE / VCS hygiene
    await syncIDEConfigs(ctx)

    if hadError
        throw new Error("Build failed with errors")

    // Make sure the returned context is up-to-date for watch mode
    ctx.prevGenerated = new Set([...ctx.outFiles])
    ctx.prevHashes = { ...ctx.prevHashes, ...ctx.newHashes }
    ctx.newHashes = {}

    return { ctx, engine }

// ──────────────────────────────────────────────────────────────
// UI layer – Responsible for colours, spinners, CLI exit codes   
// ──────────────────────────────────────────────────────────────

// CLI command – build
registerBuildCommand := =>
    program.command "build"
        .description "One-shot compile of all .civet files"
        .action async =>
            cwd := process.cwd()
            opts := { ...defaultOpts, ...program.opts<Options>() }
            try
                await runBuild(cwd, opts)
                console.log c.green("\nCivetman finished building!")
            catch e
                // runBuild will have already logged details
                process.exitCode = 1
                return

// ---------------- watch mode helpers ----------------
createWatcher := (cwd: string, opts: Options) ->
    // Polling by default only in CI; can be overridden via --force-polling.
    usePolling := opts.forcePolling || !!process.env.CI
    chokidar.watch(cwd, {
        ignored: [/node_modules/, /dist/, /(^|[\/]\\)\..*|.*\.civetmantmp$/], // ignore dotfiles and our temp files
        persistent: true,
        ignoreInitial: true,
        usePolling: usePolling,
        interval: 100,
        binaryInterval: 300,
        awaitWriteFinish: {
            stabilityThreshold: 100,
            pollInterval: 100
        }
    })

// ---------------- global watcher registry to avoid duplicate SIGINT logs ----------------
activeWatchBundles := (global as any).__civetman_watch_bundles ?? new Set<any>()
(global as any).__civetman_watch_bundles = activeWatchBundles

if !(global as any).__civetman_sigint_handler_registered
    (global as any).__civetman_sigint_handler_registered = true
    process.on "SIGINT", async =>
        // Gracefully close all active watchers and persist state exactly once
        for entry of activeWatchBundles
            try
                await entry.watcher.close()
                ctxObj := entry.ctx
                ctxObj.prevHashes = { ...ctxObj.prevHashes, ...ctxObj.newHashes }
                ctxObj.newHashes = {}
                await saveNewState(ctxObj)
            catch _
                continue
        console.log("\nCivetman watch stopped.")
        process.exit()

// Helper to add all watch-event listeners to a chokidar watcher instance
attachWatchHandlers := (watcher: any, 
                        ctx: BuildContext, 
                        cwd: string, 
                        saveStateAndSync: () => void, 
                        engine: BuildEngine) ->

    // This callback defines how a single file event is handled in watch mode.
    rebuildOne := (file: string) =>
        engine.build(file, (result: CompileResult) => {
            if result.status == 'built'
                ctx.prevHashes[file] = ctx.newHashes[file] = { sig: result.signature!, outFile: result.outFile! }
                logDebug("[REBUILD_ONE] Built", file, "->", result.outFile!)
                console.log c.green('  ✓ ' + c.cyan(result.file) + " -> " + c.green(result.outFile!))
            else if result.status == 'skip'
                // update hashes on skip to prevent re-runs
                ctx.prevHashes[file] = ctx.newHashes[file] = { sig: result.signature!, outFile: result.outFile! }
                logDebug("[REBUILD_ONE] Skipped (up to date)", file)
            else if result.status == 'error'
                logDebug("[REBUILD_ONE] Error compiling", file, result.error)
                console.error("Civetman error compiling", file, result.error)
            
            saveStateAndSync()
        })

    watcher.on 'ready', ->
        logDebug("[WATCHER] Initial scan complete and ready for changes")
        logDebug("[WATCHER] Watched paths:", watcher.getWatched())
        console.log(c.blue("Watching for changes"))

    watcher.on 'all', (event: string, changedPath: string) ->
        if !changedPath.endsWith('.civet') return // only care about civet files
        logDebug("[WATCHER] Event:", event, "on path:", changedPath)

    watcher.on 'error', (err: unknown) ->
        logDebug("[WATCHER] Error in watcher:", err)

    watcher.on "add", (abs: string) ->
        // Only react to source .civet files – ignore generated outputs
        unless abs.endsWith('.civet') return
        file := path.relative(cwd, abs)
        logDebug("[WATCHER_ADD] File added", file)
        unless ctx.sources.includes(file)
            ctx.sources.push file
            logDebug("[WATCHER_ADD] Added to sources list", file)
        rebuildOne(file)

    watcher.on "change", (abs: string) ->
        unless abs.endsWith('.civet') return
        file := path.relative(cwd, abs)
        logDebug("[WATCHER_CHANGE] File changed", file)
        rebuildOne(file)

    watcher.on "unlink", async (abs: string) =>
        unless abs.endsWith('.civet') return
        file := path.relative(cwd, abs) 
        logDebug("[WATCHER_UNLINK] File removed", file)
        await engine.remove(file)
        saveStateAndSync()

// ---------------- watch mode ----------------
registerDevCommand := =>
    logDebug("[WatchMode] Registering dev command")
    devAction := async (): Promise<void> =>
        logDebug("[WatchMode] Executing dev action")
        cwd := process.cwd()
        opts := { ...defaultOpts, ...program.opts<Options>() }
        try
            console.log c.blue("Civetman starts building in watch mode…\n")
            { ctx, engine } := await runBuild(cwd, opts)
            console.log c.green("Initial build complete! Watching for changes…\n")
            
            saveStateAndSync := debounce(async =>
                logDebug("[STATE_SYNC] Starting state sync")
                ctx.prevHashes = { ...ctx.prevHashes, ...ctx.newHashes }
                ctx.newHashes = {}
                await saveNewState(ctx)
                await syncIDEConfigs(ctx)
                logDebug("[STATE_SYNC] State sync complete")
            , 800)

            logDebug("[WATCHER] Setting up watcher in directory:", path.resolve(cwd))
            watcher := createWatcher(cwd, opts)
            logDebug("[WATCHER] Watcher instance created:", !!watcher)
            attachWatchHandlers(
                watcher, 
                ctx, 
                cwd, 
                saveStateAndSync, 
                engine)
            
            // Register this watcher for global cleanup once
            activeWatchBundles.add({ watcher, ctx })
        catch e
            console.error c.red("Watch mode failed"), e
            process.exitCode = 1
    program.command "dev"
        .description "Watch .civet files and rebuild on change"
        .action devAction

export default () =>
    // top-level CLI wiring
    program
        .name "civetman"
        .description "Use Civet language in any project – build or watch .civet files"
        .version "0.1.0"
        .option("-x, --tsx", "Generate .tsx files instead of .ts", defaultOpts.tsx)
        .option("--out-ts <dir>", "Directory to emit .ts files (repeatable or comma-separated)", collectDirs, [] as string[])
        .option("--out-tsx <dir>", "Directory to emit .tsx files (repeatable or comma-separated)", collectDirs, [] as string[])
        .option("--no-git-ignore", "Disable writing generated files to .gitignore")
        .option("--no-vscode-hide", "Disable hiding generated files in VS Code")
        .option("--inline-map <mode>", "Inline source map mode", defaultOpts.inlineMap)
        .option("--map-files", "Emit external .map files")
        .option("--concurrency <number>", "Max parallel compilations", (val) => parseInt(val, 10))
        .option("--force-polling", "Force chokidar polling even outside CI")

    registerBuildCommand()
    registerDevCommand()

    program.parse(process.argv)

// --------------------------------------------------------------
// End of experimental refactor skeleton
// --------------------------------------------------------------

// Lightweight debounce util for watch-mode side-effects
debounce := (func: Function, timeout = 1000) ->
    timer: NodeJS.Timeout | null .= null
    (...args: any[]) ->
        logDebug("[DEBOUNCE] Debouncing call with args", args)
        if timer?
            logDebug("[DEBOUNCE] Clearing previous timer")
            clearTimeout(timer)
        timer = setTimeout (->
            logDebug("[DEBOUNCE] Executing debounced function")
            func(...args)
        ), timeout

export computeHash, resolveOutputType, defaultOpts