// --------------------------------------------------------------
// import-rewriter.civet â€“ Strip .civet extensions from import/export statements
// Thin rewriting layer that uses shared parse-utils for parsing
// --------------------------------------------------------------

export interface ImportMatch {
  spec: string;
  offset: number;
  length: number;
  type: 'from' | 'side-effect';
}

/**
 * Validates that a keyword is a real import/export keyword (not part of another word)
 */
function isRealKeyword(content: string, index: number, keyword: string): boolean {
  if (index > 0 && /\w/.test(content[index - 1])) return false;
  nextChar := content[index + keyword.length];
  return !nextChar || !/\w/.test(nextChar);
}

/**
 * Check if a position is inside a comment or string literal at the top level.
 * This prevents matching import/export keywords that appear in strings or comments.
 */
function isInCommentOrString(content: string, pos: number): boolean {
  inString: '"' | "'" | null .= null;
  escapeNext .= false;
  i .= 0;

  while (i < pos && i < content.length) {
    // Handle escape sequences in strings
    if (inString && escapeNext) {
      escapeNext = false;
      i++;
      continue;
    }

    if (inString) {
      if (content[i] === '\\') {
        escapeNext = true;
        i++;
        continue;
      }
      if (content[i] === inString) {
        inString = null;
        i++;
        continue;
      }
      i++;
      continue;
    }

    // Enter string
    if (content[i] === '"' || content[i] === "'") {
      inString = content[i] as '"' | "'";
      i++;
      continue;
    }

    // Handle line comments - skip to end of line or end of input
    if (content[i] === '/' && content[i + 1] === '/') {
      // If pos is after this point and before the newline, it's in a comment
      newlinePos := content.indexOf('\n', i);
      if (newlinePos === -1 || pos < newlinePos) {
        // pos is before the newline (or there is no newline), so it's in the comment
        return true;
      }
      // Skip to after the newline
      i = newlinePos + 1;
      continue;
    }

    // Handle block comments - skip until */
    if (content[i] === '/' && content[i + 1] === '*') {
      endComment := content.indexOf('*/', i + 2);
      if (endComment === -1 || pos < endComment + 2) {
        // pos is before the end of comment (or comment doesn't end)
        return true;
      }
      // Skip past the comment
      i = endComment + 2;
      continue;
    }

    i++;
  }

  return inString !== null;
}

/**
 * Utility function to strip quotes from a string
 */
export function stripQuotes(text: string): string {
  if ((text.startsWith('"') && text.endsWith('"')) || (text.startsWith("'") && text.endsWith("'"))) {
    return text.slice(1, -1);
  }
  return text;
}

/**
 * A robust state-machine parser to find all import/export specifiers in TypeScript code.
 * Handles both import and export statements including re-exports and type-only exports.
 * 
 * Supported patterns:
 * - import { x } from './file.civet'
 * - import type { x } from './file.civet'
 * - import './file.civet' (side-effect)
 * - export { x } from './file.civet' (re-exports)
 * - export type { x } from './file.civet' (type re-exports)
 */
export function findAllImports(content: string): ImportMatch[] {
  results: ImportMatch[] := [];
  i .= 0;

  while (i < content.length) {
    // Find next 'import' or 'export' keyword
    importIdx := content.indexOf('import', i);
    exportIdx := content.indexOf('export', i);
    
    keywordIdx .= -1;
    keyword .= '';
    
    if (importIdx !== -1 && exportIdx !== -1) {
      // Both found, take the earlier one
      if (importIdx < exportIdx) {
        keywordIdx = importIdx;
        keyword = 'import';
      } else {
        keywordIdx = exportIdx;
        keyword = 'export';
      }
    } else if (importIdx !== -1) {
      keywordIdx = importIdx;
      keyword = 'import';
    } else if (exportIdx !== -1) {
      keywordIdx = exportIdx;
      keyword = 'export';
    } else {
      break; // No more keywords found
    }

    // Validate it's a real keyword
    if (!isRealKeyword(content, keywordIdx, keyword)) {
      i = keywordIdx + 1;
      continue;
    }

    // Also validate it's not in a comment or string
    if (isInCommentOrString(content, keywordIdx)) {
      i = keywordIdx + 1;
      continue;
    }

    i = keywordIdx + keyword.length;
    
    // Skip whitespace after keyword
    while (i < content.length && /\s/.test(content[i])) i++;
    
    // Check for 'type' keyword (for type-only imports/exports)
    if (content.substring(i, i + 4) === 'type') {
      i += 4; // Move past 'type'
      // Skip whitespace after 'type'
      while (i < content.length && /\s/.test(content[i])) i++;
    }

    inString: '"' | "'" | null .= null;
    braceLevel .= 0;
    foundFrom .= false;
    potentialSideEffect .= true;

    // Scan forward from the keyword
    while (i < content.length) {
      char := content[i];

      // Skip whitespace
      if (/\s/.test(char)) {
        i++;
        continue;
      }
      
      // Handle comments
      if (char === '/' && content[i + 1] === '/') {
        while (i < content.length && content[i] !== '\n') i++;
        continue;
      }
      if (char === '/' && content[i + 1] === '*') {
        i += 2;
        while (i < content.length && (content[i] !== '*' || content[i + 1] !== '/')) i++;
        i += 2;
        continue;
      }
      
      if (char === '{') {
        braceLevel++;
        potentialSideEffect = false;
        i++;
        continue;
      }
      if (char === '}') {
        braceLevel--;
        i++;
        continue;
      }

      // Check for `from` keyword only outside of braces
      if (braceLevel === 0 && content.substring(i, i + 4) === 'from') {
        prevChar := content[i - 1];
        nextChar := content[i + 4];
        if (prevChar && /\s/.test(prevChar) && nextChar && /\s/.test(nextChar)) {
          foundFrom = true;
          potentialSideEffect = false;
          i += 4; // move past 'from'
          continue;
        }
      }

      // Found the specifier
      if (char === "'" || char === '"') {
        inString = char;
        specOffset := i;
        specStart := i + 1;
        specEnd .= specStart;
        while (specEnd < content.length && content[specEnd] !== inString) specEnd++;
        spec := content.substring(specStart, specEnd);
        specLength := (specEnd - specStart) + 2;
        i = specEnd + 1;
        
        type := foundFrom ? 'from' : (potentialSideEffect ? 'side-effect' : 'from');
        results.push({ spec, offset: specOffset, length: specLength, type });
        break; // Move to next keyword match
      }
      
      // If we see a character that isn't the start of a specifier and isn't a brace,
      // it's likely a named import, so it's not a side-effect.
      if (/\w/.test(char)) {
          potentialSideEffect = false;
      }

      if (char === ';' || char === '\n') {
        break; // End of statement, move to next keyword match
      }
      
      i++;
    }
  }

  return results;
}

/**
 * Replace a substring at a specific offset and length
 */
function replaceAt(str: string, offset: number, length: number, replacement: string): string {
  return str.substring(0, offset) + replacement + str.substring(offset + length);
}

/**
 * Main function to rewrite .civet imports/exports in compiled TypeScript code.
 * Removes .civet extensions from import and export statements while preserving quote styles.
 */
export function rewriteCivetImports(code: string): string {
  imports := findAllImports(code);
  civetImports := imports.filter((m) => m.spec.endsWith('.civet'));
  
  if (civetImports.length === 0) {
    return code; // No .civet imports/exports to rewrite
  }
  
  // Replace in reverse order to preserve offsets
  result .= code;
  for (const match of civetImports.reverse()) {
    // Get the original text to preserve quote characters
    originalText := code.substring(match.offset, match.offset + match.length);
    quoteChar := originalText.startsWith('"') || originalText.startsWith("'") ? originalText[0] : undefined;
    
    // Remove .civet extension from the spec
    newSpec := match.spec.replace(/\.civet$/, '');
    
    // Rebuild with proper quotes
    newText := quoteChar ? quoteChar + newSpec + quoteChar : newSpec;
    result = replaceAt(result, match.offset, match.length, newText);
  }
  
  return result;
}
