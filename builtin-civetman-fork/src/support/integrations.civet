// ──────────────────────────────────────────────────────────────
// Integration layer – VS Code settings and .gitignore management
// ──────────────────────────────────────────────────────────────

fs from "fs-extra"
{ join } from "node:path"
import type { ParseError } from "jsonc-parser"
{ parseTree as jsoncParseTree, findNodeAtLocation as jsoncFindNodeAtLocation, getNodeValue as jsoncGetNodeValue, modify as jsoncModify, applyEdits as jsoncApplyEdits } from "jsonc-parser"
import { toPosix } from "./utils.civet"
import { safeWrite } from "./fs.civet"
import type { BuildContext } from "./config.civet"

// Sync both IDE configs
export syncIDEConfigs := async (ctx: BuildContext) =>
    await addVscodeExcludes(ctx)
    await addGitignoreEntries(ctx)

export addVscodeExcludes := async (ctx: BuildContext) =>
    // Build the list of patterns we should hide inside VS Code
    files := [...ctx.outFiles]
    
    placeholder := "below is generated by civetman"
    managedKey := "civetman:managed"  // Track civetman-managed files
    configKey := "files.exclude"
    tmpGlob := "**/*.civetmantmp"

    vscodeDir := join(ctx.cwd, ".vscode")
    settingsFile := join(vscodeDir, "settings.json")

    await fs.ensureDir(vscodeDir)
    await fs.ensureFile(settingsFile)

    content .= await fs.readFile(settingsFile, "utf8")
    errors: ParseError[] .= []
    tree .= jsoncParseTree(content, errors, { allowTrailingComma: true })
    if !tree
        // File is empty or contains invalid JSONC – start from a clean state
        content = "{}\n"
        errors = []
        tree = jsoncParseTree(content, errors, { allowTrailingComma: true })
        if !tree
            // Still cannot parse (extremely unlikely) – bail early to avoid corruption
            return

    node := jsoncFindNodeAtLocation(tree, [configKey])
    existing := (node ? jsoncGetNodeValue(node) : {}) as Record<string, boolean>

    // Extract previously managed files for cleanup logic
    rootManagedNode := jsoncFindNodeAtLocation(tree, [managedKey])
    previouslyManaged: string[] .= []
    if rootManagedNode
        previouslyManaged = (jsoncGetNodeValue(rootManagedNode) as string[]) || []
    else
        // Fallback for migration: check inside files.exclude (the old, broken location)
        excludeManagedNode := jsoncFindNodeAtLocation(tree, [configKey, managedKey])
        previouslyManaged = (excludeManagedNode ? jsoncGetNodeValue(excludeManagedNode) as string[] : undefined) || []

    // Preserve any excludes that are not ours and not previously managed
    manual := Object.entries(existing).reduce((acc: Record<string, boolean>, [k,v]) =>
        if k == managedKey return acc  // Skip metadata key
        if k == placeholder return acc  // Skip our marker
        if previouslyManaged.includes(k) return acc  // Skip old managed files
        if typeof v === 'boolean' then acc[k] = v  // Only preserve boolean values
        acc
    , {})

    newExclude := if ctx.opts.vscodeHide
        // Normalize paths to POSIX for cross-platform .vscode/settings.json
        dynamic := files.reduce((acc: Record<string, boolean>, f: string) => ({ ...acc, [toPosix(f)]: true }), {})
        dynamic[tmpGlob] = true
        { 
          ...manual, 
          [placeholder]: true, 
          ...dynamic
        }
    else
        // When disabled, remove all managed entries
        manual

    // Store managed files metadata separately (normalized to POSIX)
    managedMetadata := if ctx.opts.vscodeHide then files.map(toPosix) else undefined

    edits := jsoncModify(content, [configKey], newExclude, { formattingOptions: { insertSpaces: true, tabSize: 2 } })
    newContent .= jsoncApplyEdits(content, edits)
    
    // Add/remove managed metadata AT THE ROOT
    metadataEdits := jsoncModify(newContent, [managedKey], managedMetadata, { formattingOptions: { insertSpaces: true, tabSize: 2 } })
    newContent = jsoncApplyEdits(newContent, metadataEdits)
    
    if newContent != content
        await fs.writeFile(settingsFile, newContent, "utf8")
    return

export addGitignoreEntries := async (ctx: BuildContext) =>
    gitignorePath := join(ctx.cwd, ".gitignore")
    startMarker := "# civetman:start - Managed by civetman. DO NOT EDIT THIS BLOCK."
    endMarker := "# civetman:end - End of civetman managed block."
    civetmanDirEntry := ".civetman/"

    await fs.ensureFile(gitignorePath)
    original := await fs.readFile(gitignorePath, "utf8")
    lines := original.split('\n')

    // Filter out our managed entries, preserving all other lines.
    // This is self-healing if the file was corrupted.
    nonManagedLines := [] as string[]
    inManagedBlock .= false
    for line of lines
        trimmed := line.trim()
        if trimmed == startMarker
            inManagedBlock = true
            continue
        if trimmed == endMarker
            inManagedBlock = false
            continue
        if trimmed == civetmanDirEntry
            continue
        if !inManagedBlock
            nonManagedLines.push(line)

    // Clean up trailing blank lines to prevent them from accumulating
    while nonManagedLines.length > 0 && nonManagedLines[nonManagedLines.length - 1].trim() === ''
        nonManagedLines.pop()
    
    // Create the new managed block, sorted for determinism
    // Normalize paths to POSIX for cross-platform .gitignore
    managedBlock := if ctx.opts.gitIgnore
        [startMarker, ...[...ctx.outFiles].map(toPosix).sort(), endMarker].join('\n')
    else
        ""

    // Reconstruct the file content
    newContent .= nonManagedLines.join('\n').trimEnd()
    if newContent
        newContent += '\n\n'
    
    // Add the managed block if it exists
    if managedBlock
        newContent += managedBlock + '\n\n'

    // Always ensure the .civetman directory is ignored
    newContent += civetmanDirEntry + '\n'

    if newContent.trim() != original.trim()
        await safeWrite(gitignorePath, newContent)
    return

