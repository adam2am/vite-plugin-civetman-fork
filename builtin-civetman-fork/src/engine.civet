// --------------------------------------------------------------
// engine.civet â€“ shared BuildEngine for build & watch pipelines 
// decides skip-vs-compile, delegates to pool, then calls writeOutputAndGetResult
// --------------------------------------------------------------

import fs from "fs-extra"
import { WorkerPool } from "./workerPool.civet"

// Import helpers and types from the main module.
import { 
    writeOutputAndGetResult,
    resolveOutputType,
    computeHash,
    buildFingerprint,
    fileToOutFile,
    logDebug,
    type BuildContext, 
    type CompileResult 
} from "./main-refactored.civet"
import { compile } from "@danielx/civet"

export class BuildEngine
    ctx: BuildContext
    pool: WorkerPool
    inFlight: Map<string, Promise<any>>

    constructor(ctx: BuildContext)
        @ctx = ctx
        concurrency := Math.max(1, (@ctx.opts.concurrency ?? 1))
        @pool = new WorkerPool(concurrency)
        @inFlight = new Map<string, Promise<any>>()

    // Build / rebuild *all* sources currently in ctx.sources
    async buildAll(onProgress?: (result: CompileResult) => void)
        tasks := @ctx.sources.map (file) => @build(file, onProgress)
        await Promise.allSettled(tasks)

    // Build a single file. Dedupe if already in progress.
    build(file: string, onProgress?: (result: CompileResult) => void)
        if @inFlight.has(file)
            return @inFlight.get(file)!

        task := @runCompileTask(file).then (result: CompileResult) =>
            onProgress?.(result)
            return result
        .catch (error: any) =>
            result := { file, status: 'error', error: error } as CompileResult
            onProgress?.(result)
            return result

        // Track promise for deduplication.
        @inFlight.set(file, task)
        // Clean up once finished.
        task.finally => @inFlight.delete(file)
        return task

    async runCompileTask(file: string): Promise<CompileResult>
        isTsx := resolveOutputType(@ctx, file)
        content := await fs.readFile(file, "utf8")
        signature := computeHash(
            content +
            JSON.stringify({ tsx: isTsx, inlineMap: @ctx.opts.inlineMap, mapFiles: @ctx.opts.mapFiles }) +
            buildFingerprint
        )

        // Skip check
        prev := @ctx.prevHashes[file]
        expectedOut := fileToOutFile(file, isTsx)
        if prev and prev.sig == signature and prev.outFile == expectedOut and await fs.exists(expectedOut)
            @ctx.outFiles.add(expectedOut)
            if @ctx.opts.mapFiles and await fs.exists(expectedOut + ".map")
                @ctx.outFiles.add(expectedOut + ".map")
            logDebug("[COMPILE] Skipping (signature match)", file)
            return { status: "skip", file, outFile: expectedOut, signature: signature }

        code .= ""
        mapJson .= null

        // Use worker pool if available and concurrency allows, otherwise compile in-process.
        if (@ctx.opts.concurrency ?? 1) > 1 and @pool.poolAvailable
            logDebug("[COMPILE] Compiling with worker", file)
            workerResult := await @pool.exec({ file, isTsx, inlineMap: @ctx.opts.inlineMap })
            code = workerResult.code
            mapJson = workerResult.mapJson
        else
            logDebug("[COMPILE] Compiling in-process", file)
            compileResult := await compile(content, { filename: file, sourceMap: true })
            code = compileResult.code
            mapJson = compileResult.sourceMap.json(file, expectedOut)

        return await writeOutputAndGetResult(@ctx, file, isTsx, code, mapJson, signature)

    // Handle a source deletion.
    async remove(file: string)
        @ctx.sources = @ctx.sources.filter (f) => f !== file
        delete @ctx.prevHashes[file]
        delete @ctx.newHashes[file]

        tsFile := file.replace(".civet", ".ts")
        tsxFile := file.replace(".civet", ".tsx")
        for out of [tsFile, tsxFile]
            await @removeOutputFile(out)
    
    async removeOutputFile(file: string)
        try
            if await fs.exists(file)
                await fs.unlink(file)
            if await fs.exists(file + ".map")
                await fs.unlink(file + ".map")
        catch _
            // best-effort
        
        @ctx.outFiles.delete(file)
        @ctx.outFiles.delete(file + ".map")
    

