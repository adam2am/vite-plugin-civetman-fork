c from "picocolors"
{ program } from "commander"
fs from "fs-extra"
glob from "fast-glob"
{ join } from "node:path"
path from "node:path"
chokidar from "chokidar"
ora from "ora"
{ compile } from "@danielx/civet"
{ parseTree as jsoncParseTree, findNodeAtLocation as jsoncFindNodeAtLocation, getNodeValue as jsoncGetNodeValue, modify as jsoncModify, applyEdits as jsoncApplyEdits } from "jsonc-parser"

function debounce<T>(func: T, timeout = 1000): T
    timer .= null as any
    (
        (...args: any) => 
            clearTimeout timer
            timer = setTimeout => (func as any)(...args), timeout
    ) as any

cwd := process.cwd()

type Options = 
    tsx: boolean, 
    gitIgnore: boolean, 
    vscodeHide: boolean, 
    inlineMap: "full" | "fileurl" | "none", 
    mapFiles: boolean

opts .= null as unknown as Options
defaultOpts: Options := 
    tsx: false, 
    gitIgnore: true, 
    vscodeHide: false, 
    inlineMap: "none", 
    mapFiles: true


collectFiles := async => 
    new Set await glob "**/*.civet", ignore: ["node_modules/**/*", "dist/**/*"], cwd: cwd


compileFile := async (file: string) => {
    content := await fs.readFile(file, "utf8");
    { code, sourceMap } := await compile(content, { 
        filename: file, 
        sourceMap: true 
    }) as { code: string; sourceMap: any };
    return {
        code: "// Source: " + file + "\n" +
              "// Generated by Civetman\n\n" +
              code,
        sourceMap
    };
}

fileToOutFile := (file: string, tsx: boolean) => file.replace(".civet", tsx ? ".tsx" : ".ts")

buildFile := async (file: string, tsx: boolean) => {
    outFile := fileToOutFile(file, tsx);
    { code, sourceMap } := await compileFile(file);
    // use standard .ts/.tsx.map naming
    mapFile := outFile + ".map"
    codeWithMap .= code;
    if opts.inlineMap === "full"
        mapJson := sourceMap.json(file, outFile)
        base64Map := Buffer.from(JSON.stringify(mapJson)).toString("base64")
        codeWithMap += `\n//# sourceMappingURL=data:application/json;base64,${base64Map}\n`
    if opts.mapFiles
        await fs.writeFile(mapFile!, JSON.stringify(sourceMap.json(file, outFile)), "utf8")
        if opts.inlineMap === "fileurl"
            codeWithMap += `\n//# sourceMappingURL=${path.basename(mapFile)}\n`
    await fs.writeFile(outFile, codeWithMap, "utf8")
    return outFile;
}

civetmanVscodeConfigPlaceholder := "below is generated by civetman"
vscodeConfigFileExludeKey := "files.exclude"
vscodeConfigDir := join cwd, ".vscode"
vscodeConfigFile := join vscodeConfigDir, "settings.json"
addVscodeConfigFileExclude := debounce(async (files: string[]) =>
    // update or remove our excludes based on vscodeHide
    spinner := ora c.blue """Updating VSCode files.exclude"""
    spinner.start()

    await fs.ensureDir vscodeConfigDir
    await fs.ensureFile vscodeConfigFile

    content := await fs.readFile(vscodeConfigFile, "utf8")
    errors := [] as any[]
    tree := jsoncParseTree(content, errors, { allowTrailingComma: true })

    if !tree
        spinner.warn("Could not parse .vscode/settings.json, skipping update.")
        return

    node := jsoncFindNodeAtLocation(tree, [vscodeConfigFileExludeKey])
    existing := (node ? jsoncGetNodeValue(node) : {}) as Record<string, boolean>

    // keep manual excludes (not ours)
    manual := Object.entries(existing).reduce((acc: Record<string, boolean>, [k, v]) => 
        if k !== civetmanVscodeConfigPlaceholder && !files.includes(k)
            acc[k] = v
        acc
    , {})

    newExclude := if opts.vscodeHide
        filesToExclude := files.reduce((acc, f) => ({ ...acc, [f]: true }), {})
        { ...manual, [civetmanVscodeConfigPlaceholder]: true, ...filesToExclude }
    else
        manual

    edits := jsoncModify(content, [vscodeConfigFileExludeKey], newExclude, { formattingOptions: { insertSpaces: true, tabSize: 2 } })
    newContent := jsoncApplyEdits(content, edits)
    await fs.writeFile(vscodeConfigFile, newContent, "utf8")

    spinner.stop()
    spinner.succeed()
)

gitignoreFile := join cwd, ".gitignore"
gitignoreStart := """
    # Generated by Civetman
    # DO NOT ADD CONTENT BELOW THIS (They will be removed by Civetman)
"""
addGitignore := debounce(
    async (files: string[]) => 
        spinner := ora c.blue """Updating .gitignore"""
        spinner.start()

        await fs.ensureFile gitignoreFile
        gitignore := await fs.readFile gitignoreFile, "utf8"
        start := gitignore.indexOf gitignoreStart
        before := start === -1 ? gitignore : gitignore.slice(0, start)

        newContent := if opts.gitIgnore
            before.trimEnd() + "\n\n" + gitignoreStart + "\n" + files.join("\n")
        else
            before.trimEnd()

        await fs.writeFile gitignoreFile, newContent, "utf8"

        spinner.stop()
        spinner.succeed()
)
    
program
    .name "civetman" 
    .description "Use Civet in any projects!" 
    .version "0.0.1"
    .option "-x, --tsx", "Generate `.tsx` files instead of `.ts` files"
    .option "--no-git-ignore", "Disable writing to .gitignore file"
    .option "--vscode-hide", "Hide build outputs in VSCode via files.exclude"
    .option "--inline-map <mode>", "Inline source map mode: 'full' (embed full base64), 'fileurl' (embed file URL), or 'none' (no comment)", "fileurl"
    .option "--no-map-files", "Disable emitting external .map files"

program
    .command "build"
    .description "Start building Civet files" 
    .action async => 
        console.log c.blue """Civetman starts building...\n"""

        spinner := ora c.blue """Building Civet files\n"""
        files := await collectFiles()
        outFiles := [] as string[]
        for file of files
            outFile := await buildFile file, opts.tsx
            outFiles.push outFile
            spinner.succeed """
                #{c.cyan file} -> #{c.green outFile}
            """
        spinner.stop()
        spinner.succeed("All Civet files built!\n")
        
        // Add both generated .ts/.tsx and their .map files to VSCode hides and .gitignore
        filesToProcess := opts.mapFiles ? [...outFiles, ...outFiles.map((f: string) => f + ".map")] : outFiles
        await addVscodeConfigFileExclude filesToProcess
        await addGitignore filesToProcess

        console.log c.green """\nCivetman finished building!"""

        return

program
    .command "dev"
    .description "Start building Civet files in watch mode"
    .action async => 
        console.log c.blue """Civetman starts building in watch mode...\n"""
        spinner := ora c.blue """Building Civet files\n"""

        files := await collectFiles()
        outFiles := new Set<string>()

        buildOneFile := async (file: string) => 
            outFile := await buildFile file, opts.tsx
            outFiles.add outFile
            spinner.succeed """
                #{c.cyan file} -> #{c.green outFile}
            """

        watcher := chokidar.watch [...files, cwd], ignored: [/node_modules/gi, /dist/gi]
        watcher.on "add", async (fileAbsolute) => 
            file := path.relative cwd, fileAbsolute
            if file.endsWith(".civet") 
                await buildOneFile file
                files.add file
                watcher.add file
        
                // Add both .ts/.tsx and their .map files to VSCode hides and .gitignore on new file
                filesToProcess := opts.mapFiles ? [...outFiles, ...[...outFiles].map((f: string) => f + ".map")] : [...outFiles]
                await addVscodeConfigFileExclude filesToProcess
                await addGitignore filesToProcess
        
        watcher.on "change", async (fileAbsolute) => 
            file := path.relative cwd, fileAbsolute
            if files.has file
                await buildOneFile file
        
        watcher.on 'unlink', async (fileAbsolute) => 
            file := path.relative cwd, fileAbsolute
            if files.has file
                files.delete file
                outFile := fileToOutFile file, opts.tsx
                outFiles.delete outFile
                fs.unlink join cwd, outFile
                // Delete the corresponding .map file if mapFiles is enabled
                if opts.mapFiles
                    fs.unlink join cwd, outFile + ".map"
                // Recompute which files to add to excludes/gitignore
                filesToProcess := opts.mapFiles ? [...outFiles, ...[...outFiles].map((f: string) => f + ".map")] : [...outFiles]
                await addVscodeConfigFileExclude filesToProcess
                await addGitignore filesToProcess

        process.on 'beforeExit', => watcher.close()

        return

export default () => 
    program.hook 'preAction' , => opts = { ...defaultOpts, ...program.opts<Options>() };
    program.parse process.argv
