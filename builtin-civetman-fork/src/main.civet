c from "picocolors"
{ program } from "commander"
fs from "fs-extra"
glob from "fast-glob"
{ join } from "node:path"
path from "node:path"
chokidar from "chokidar"
ora from "ora"
{ compile } from "@danielx/civet"
{ parseTree as jsoncParseTree, findNodeAtLocation as jsoncFindNodeAtLocation, getNodeValue as jsoncGetNodeValue, modify as jsoncModify, applyEdits as jsoncApplyEdits } from "jsonc-parser"
crypto from "node:crypto"
os from "node:os"

function debounce<T>(func: T, timeout = 1000): T
    timer .= null as any
    (
        (...args: any) => 
            clearTimeout timer
            timer = setTimeout => (func as any)(...args), timeout
    ) as any

cwd := process.cwd()

type Options = 
    tsx: boolean, 
    gitIgnore: boolean, 
    vscodeHide: boolean, 
    inlineMap: "full" | "fileurl" | "none", 
    mapFiles: boolean
    outTs?: string[],
    outTsx?: string[],
    concurrency?: number

opts .= null as unknown as Options
defaultOpts: Options := 
    tsx: false, 
    gitIgnore: true, 
    vscodeHide: true, 
    inlineMap: "full", 
    mapFiles: false,
    concurrency: Math.min(2, (os.cpus()?.length || 2))

// Determine for each .civet file whether to emit TSX (true) or TS (false)
resolveOutputType := (file: string): boolean =>
    relativeFile := path.relative(cwd, file)

    findLongestMatch := (dirs: string[]) =>
        matches := (dirs || []).filter((dir: string) => {
            normalized := path.normalize(dir)
            // '.' matches everything
            return normalized === '.' || relativeFile.startsWith(normalized + path.sep)
        })
        if !matches.length return null
        matches.sort((a,b) => b.length - a.length)[0]

    tsxMatch := findLongestMatch(opts.outTsx ? opts.outTsx : [])
    tsMatch  := findLongestMatch(opts.outTs  ? opts.outTs  : [])
    if tsxMatch && tsMatch
        // more specific folder wins
        return tsxMatch.length >= tsMatch.length
    if tsxMatch return true
    if tsMatch  return false
    return opts.tsx

// Helper for collecting repeatable or comma-separated directory flags
collectDirs := (val: string, prev: string[]) =>
    prev.concat(
        val.split(",")
            .map((s: string) => s.trim())
            .filter((s): s is string => !!s)
    )

collectFiles := async => 
    new Set await glob "**/*.civet", ignore: ["node_modules/**/*", "dist/**/*"], cwd: cwd


compileFile := async (file: string, content?: string) => {
    if content == null
        content = await fs.readFile(file, "utf8")
    { code, sourceMap } := await compile(content, { 
        filename: file, 
        sourceMap: true 
    }) as { code: string; sourceMap: any }
    return { code, sourceMap }
}

fileToOutFile := (file: string, tsx: boolean) => 
    file.replace(".civet", tsx ? ".tsx" : ".ts")

cleanupStaleFiles := async (outFiles: string[], allCivetFiles: Set<string>) => {
    spinner := ora(c.blue("Cleaning up stale output files...")).start()

    // From all .civet files, create a set of all *possible* output file names
    potentialFiles := new Set<string>()
    for file of allCivetFiles
        tsFile := file.replace(".civet", ".ts")
        tsxFile := file.replace(".civet", ".tsx")
        potentialFiles.add tsFile
        potentialFiles.add tsxFile
        potentialFiles.add(tsFile + ".map")
        potentialFiles.add(tsxFile + ".map")

    // Create a set of the files that were *actually* generated in this run
    actuallyGenerated := new Set(outFiles)
    if opts.mapFiles
        for f of outFiles
            actuallyGenerated.add(f + ".map")

    cleanedCount .= 0
    for file of potentialFiles
        if !actuallyGenerated.has(file) && await fs.exists(file)
            await fs.unlink file
            cleanedCount++
    
    if cleanedCount > 0
        spinner.succeed `Cleaned up ${cleanedCount} stale output file(s)!`
    else
        spinner.stop() // Silently stop if nothing to do
}

// Helper to write files atomically to prevent partial writes on crash
safeWrite := async (filePath: string, data: string | Buffer) =>
    tmp := filePath + "." + crypto.randomUUID() + ".civetmantmp"
    await fs.writeFile(tmp, data, "utf8")
    await fs.rename(tmp, filePath)

// Helper to delete stray .civetmantmp files that belong to our generated outputs
cleanupTmpFiles := async (baseFiles: string[]) =>
    for base of baseFiles
        pattern := base + ".*.civetmantmp"
        tmpFiles := await glob(pattern, cwd: cwd)
        for tmp of tmpFiles
            try
                await fs.unlink(tmp)
            catch _
                // ignore

buildFile := async (file: string, tsx: boolean, content?: string) => {
    outFile := fileToOutFile(file, tsx)
    { code, sourceMap } := await compileFile(file, content)
    // use standard .ts/.tsx.map naming
    mapFile := outFile + ".map"
    codeWithMap .= code;
    if opts.inlineMap === "full"
        mapJson := sourceMap.json(file, outFile)
        base64Map := Buffer.from(JSON.stringify(mapJson)).toString("base64")
        codeWithMap += `\n//# sourceMappingURL=data:application/json;base64,${base64Map}\n`
    if opts.mapFiles
        await safeWrite(mapFile!, JSON.stringify(sourceMap.json(file, outFile)))
        if opts.inlineMap === "fileurl"
            codeWithMap += `\n//# sourceMappingURL=${path.basename(mapFile)}\n`
    await safeWrite(outFile, codeWithMap)
    return outFile;
}

civetmanVscodeConfigPlaceholder := "below is generated by civetman"
vscodeConfigFileExludeKey := "files.exclude"
vscodeConfigDir := join cwd, ".vscode"
vscodeConfigFile := join vscodeConfigDir, "settings.json"
addVscodeConfigFileExclude := debounce(async (files: string[]) =>
    // update or remove our excludes based on vscodeHide
    spinner := ora c.blue """Updating VSCode files.exclude"""
    spinner.start()

    await fs.ensureDir vscodeConfigDir
    await fs.ensureFile vscodeConfigFile

    content := await fs.readFile(vscodeConfigFile, "utf8")
    errors := [] as any[]
    tree := jsoncParseTree(content, errors, { allowTrailingComma: true })

    if !tree
        spinner.warn("Could not parse .vscode/settings.json, skipping update.")
        return

    node := jsoncFindNodeAtLocation(tree, [vscodeConfigFileExludeKey])
    existing := (node ? jsoncGetNodeValue(node) : {}) as Record<string, boolean>

    // keep manual excludes (not ours)
    manual := Object.entries(existing).reduce((acc: Record<string, boolean>, [k, v]) => 
        if k !== civetmanVscodeConfigPlaceholder && !files.includes(k)
            acc[k] = v
        acc
    , {})

    newExclude := if opts.vscodeHide
        filesToExclude := files.reduce((acc, f) => ({ ...acc, [f]: true }), {})
        { ...manual, [civetmanVscodeConfigPlaceholder]: true, ...filesToExclude }
    else
        manual

    edits := jsoncModify(content, [vscodeConfigFileExludeKey], newExclude, { formattingOptions: { insertSpaces: true, tabSize: 2 } })
    newContent := jsoncApplyEdits(content, edits)
    await fs.writeFile(vscodeConfigFile, newContent, "utf8")

    spinner.stop()
    spinner.succeed()
)

gitignoreFile := join cwd, ".gitignore"
gitignoreStart := "# civetman:start - Managed by civetman. DO NOT EDIT THIS BLOCK."
gitignoreEnd := "# civetman:end - End of civetman managed block."

addGitignore := debounce(
    async (files: string[]) => 
        spinner := ora c.blue """Updating .gitignore"""
        spinner.start()

        await fs.ensureFile gitignoreFile
        original := await fs.readFile gitignoreFile, "utf8"

        startIdx := original.indexOf gitignoreStart
        endIdx := startIdx === -1 ? -1 : original.indexOf gitignoreEnd, startIdx + gitignoreStart.length

        [before, after] := if startIdx != -1 && endIdx != -1
            [original.substring(0, startIdx), original.substring(endIdx + gitignoreEnd.length)]
        else
            [original, ""]

        rawContent := if opts.gitIgnore
            managed := [gitignoreStart, ...files, gitignoreEnd].join("\n")
            before.trimEnd() + "\n\n" + managed + "\n\n" + after.trimStart()
        else
            before.trimEnd() + "\n\n" + after.trimStart()

        newContent := rawContent.trimEnd() + "\n"

        if newContent !== original
        await fs.writeFile gitignoreFile, newContent, "utf8"

        spinner.stop()
        spinner.succeed()
)

// Manifest-driven cleanup helpers -----------------------------
manifestDir := join cwd, ".civetman"
manifestFile := join manifestDir, "manifest.json"

loadManifest := async =>
    if await fs.exists(manifestFile)
        try
            JSON.parse(await fs.readFile(manifestFile, "utf8"))
        catch
            { version: 1, generated: [] }
    else
        { version: 1, generated: [] }

saveManifest := async (set: Set<string>) =>
    await fs.ensureDir(manifestDir)
    await fs.writeFile(manifestFile, JSON.stringify({ version: 1, generated: [...set] }, null, 2), "utf8")

ensureGitignoreManifestEntry := debounce(async =>
    await fs.ensureFile(gitignoreFile)
    content := await fs.readFile(gitignoreFile, "utf8")
    entry := "/.civetman/"
    if !content.split("\n").map((l) => l.trim()).includes(entry)
        await fs.appendFile(gitignoreFile, "\n" + entry + "\n")
)

pruneStaleOutputs := async (oldSet: Set<string>, newSet: Set<string>) =>
    stale := [...oldSet].filter((f) => !newSet.has(f))
    for file of stale
        try
            if (await fs.exists(file)) await fs.unlink(file)
            if (await fs.exists(file + ".map")) await fs.unlink(file + ".map")
        catch e
            console.error("Could not delete stale file", file, e)
    filesArr := [...newSet]
    await addVscodeConfigFileExclude filesArr
    await addGitignore filesArr

// Compute a content hash (sha1) for incremental build checks
computeHash := (input: string): string =>
    crypto.createHash("sha1").update(input).digest("hex")

// ---------------- Hash-based manifest helpers ----------------
// Stores { [sourceFile]: { hash: string, outFile: string } }
// Separate file so we keep backward-compat with the existing generated-files manifest.
hashManifestFile := join manifestDir, "hashes.json"

loadHashManifest := async =>
    if await fs.exists(hashManifestFile)
        try
            JSON.parse(await fs.readFile(hashManifestFile, "utf8")) as Record<string, { hash: string, outFile: string }>
        catch
            {}
    else
        {}

saveHashManifest := async (map: Record<string, { hash: string, outFile: string }>) =>
    await fs.ensureDir(manifestDir)
    await fs.writeFile(hashManifestFile, JSON.stringify(map, null, 2), "utf8")

program
    .name "civetman"
    .description "Use Civet in any projects!"
    .version "0.0.1"
    .option("-x, --tsx", "Generate .tsx files instead of .ts", defaultOpts.tsx)
    .option(
        "--out-ts <dir>",
        "Directory to emit .ts files (repeatable or comma-separated)",
        collectDirs,
        [] as string[]
    )
    .option(
        "--out-tsx <dir>",
        "Directory to emit .tsx files (repeatable or comma-separated)",
        collectDirs,
        [] as string[]
    )
    .option("--no-git-ignore", "Disable writing generated files to .gitignore")
    .option("--no-vscode-hide", "Disable hiding generated files in VS Code")
    .option("--inline-map <mode>", "Inline source map mode: 'full', 'fileurl', or 'none'", defaultOpts.inlineMap)
    .option("--map-files", "Enable emitting external .map files")
    .option("--concurrency <number>", "Max parallel compilations (default: 4)", (val) => parseInt(val, 10))

program
    .command "build"
    .description "Start building Civet files" 
    .action async => 
        console.log c.blue """Civetman starts building...\n"""

        spinner := ora c.blue """Building Civet files\n"""

        files := await collectFiles()
        fileArr := [...(files as Set<string>)]

        // Compute list of possible output base files for tmp cleanup
        potentialBases := [] as string[]
        for f of (files as Set<string>)
            potentialBases.push(fileToOutFile(f, false))
            potentialBases.push(fileToOutFile(f, true))
            if opts.mapFiles
                potentialBases.push(fileToOutFile(f, false) + ".map")
                potentialBases.push(fileToOutFile(f, true) + ".map")

        // Include previously generated files from manifest
        oldManifestPre := await loadManifest()
        for prev of (oldManifestPre.generated || [])
            potentialBases.push(prev as string)

        await cleanupTmpFiles(potentialBases)

        // Load previous hash manifest for incremental builds
        oldHashes := await loadHashManifest()
        newHashes: Record<string, { hash: string, outFile: string }> := {}

        outFiles := [] as string[]

        // ---------- Parallel compilation ----------
        concurrency := Math.max(1, (opts.concurrency ? opts.concurrency : Math.min(2, (os.cpus()?.length || 2))))
        chunkSize := concurrency

        processOne := async (file: string) => {
            // Decide output type before hashing so we can detect ts→tsx flips
            isTsx := resolveOutputType(file)
            expectedOutFile := fileToOutFile(file, isTsx)

            // Read once for hashing & potential compile reuse
            content := await fs.readFile(file, "utf8")
            newHash := computeHash(content)
            prev := oldHashes[file]
            if prev && prev.hash == newHash && prev.outFile == expectedOutFile && await fs.exists(expectedOutFile)
                // No changes, reuse previous output
                outFiles.push expectedOutFile
                newHashes[file] = { hash: newHash, outFile: expectedOutFile }
                spinner.info(c.dim(file) + " (skipped – unchanged)")
                return
            // Otherwise compile
            resultFile := await buildFile(file, isTsx, content)
            outFiles.push resultFile
            newHashes[file] = { hash: newHash, outFile: resultFile }
            spinner.succeed(c.cyan(file) + " -> " + c.green(resultFile))
        }

        // Iterate in chunks respecting the chosen concurrency level
        for i of [0...fileArr.length] by chunkSize
            slice := fileArr.slice(i, i + chunkSize)
            await Promise.all slice.map(processOne)

        spinner.stop()
        spinner.succeed("All Civet files processed!\n")

        await cleanupStaleFiles outFiles, files

        // Load previous manifest (generated file list) for stale detection
        oldManifest := await loadManifest()
        oldSet := new Set(oldManifest.generated as string[])

        // Manifest prune & save
        newSet := new Set(outFiles)
        await pruneStaleOutputs oldSet, newSet
        await saveManifest newSet

        // Persist new hash data
        await saveHashManifest newHashes

        // Add both generated .ts/.tsx and their .map files to VSCode hides and .gitignore
        filesToProcess := opts.mapFiles ? [...outFiles, ...outFiles.map((f: string) => f + ".map")] : outFiles
        await addVscodeConfigFileExclude filesToProcess
        await addGitignore filesToProcess

        console.log c.green """\nCivetman finished building!"""

        return

program
    .command "dev"
    .description "Start building Civet files in watch mode"
    .action async => 
        console.log c.blue """Civetman starts building in watch mode...\n"""
        spinner := ora c.blue """Building Civet files\n"""

        files := await collectFiles()
        outFiles := new Set<string>()

        // Cleanup stray tmp files before watch starts
        potentialBasesDev := [] as string[]
        for f of (files as Set<string>)
            potentialBasesDev.push(fileToOutFile(f, false))
            potentialBasesDev.push(fileToOutFile(f, true))
            if opts.mapFiles
                potentialBasesDev.push(fileToOutFile(f, false) + ".map")
                potentialBasesDev.push(fileToOutFile(f, true) + ".map")
        oldManifestDev := await loadManifest()
        for prev of (oldManifestDev.generated || [])
            potentialBasesDev.push(prev as string)
        await cleanupTmpFiles(potentialBasesDev)

        // Load previous manifest for watch mode
        oldManifest := await loadManifest()
        oldSet .= new Set(oldManifest.generated as string[])

        buildOneFile := async (file: string) => {
            try
                isTsx := resolveOutputType(file)
                outFile := await buildFile(file, isTsx)
                outFiles.add outFile
                spinner.succeed(c.cyan(file) + " -> " + c.green(outFile))

                // Clean up stale files from other extensions (ts vs tsx)
                otherExt := isTsx ? ".ts" : ".tsx"
                staleOutFile := file.replace(".civet", otherExt)
                if await fs.exists(staleOutFile)
                    await fs.unlink(staleOutFile)
                if await fs.exists(staleOutFile + ".map")
                    await fs.unlink(staleOutFile + ".map")
                
                // If map files are disabled, ensure no .map file for the current output
                if !opts.mapFiles
                    if await fs.exists(outFile + ".map")
                        await fs.unlink(outFile + ".map")
            catch e
                console.error("Civetman error compiling", file, e)
        }

        for file of (files as Set<string>)
          await buildOneFile(file)
        
        spinner.succeed("Initial build complete!\n")

        // After initial build, prune & save
        await pruneStaleOutputs oldSet, outFiles
        await saveManifest outFiles
        oldSet = new Set(outFiles)

        watcher := chokidar.watch [...(files as Set<string>), cwd], ignored: [/node_modules/gi, /dist/gi]
        watcher.on "add", async (fileAbsolute: string) =>
            try
                file := path.relative cwd, fileAbsolute
                if file.endsWith(".civet")
                    await buildOneFile file
                    files.add file
                    watcher.add file

                    // Add both .ts/.tsx and their .map files to VSCode hides and .gitignore on new file
                    filesToProcess := opts.mapFiles ? [...outFiles, ...[...outFiles].map((f: string) => f + ".map")] : [...outFiles]
                    await addVscodeConfigFileExclude filesToProcess
                    await addGitignore filesToProcess
                    // update manifest
                    await saveManifest outFiles
            catch e
                console.error e

        watcher.on "change", async (fileAbsolute: string) =>
            try
                file := path.relative cwd, fileAbsolute
                if files.has file
                    await buildOneFile file
            catch e
                console.error e

        watcher.on 'unlink', async (fileAbsolute: string) => {
            try
                file := path.relative cwd, fileAbsolute
                if files.has file
                    files.delete file

                    // When a civet file is deleted, remove all possible outputs and maps
                    tsFile := fileToOutFile(file, false)
                    tsxFile := fileToOutFile(file, true)
                    outFiles.delete(tsFile)
                    outFiles.delete(tsxFile)
                    if await fs.exists(tsFile)
                        await fs.unlink(tsFile)
                    if await fs.exists(tsFile + ".map")
                        await fs.unlink(tsFile + ".map")
                    if await fs.exists(tsxFile)
                        await fs.unlink(tsxFile)
                    if await fs.exists(tsxFile + ".map")
                        await fs.unlink(tsxFile + ".map")

                    // Recompute which files to add to excludes/gitignore
                    filesToProcess := opts.mapFiles ? [...outFiles, ...[...outFiles].map((f: string) => f + ".map")] : [...outFiles]
                    await addVscodeConfigFileExclude filesToProcess
                    await addGitignore filesToProcess
                    // update manifest after deletion
                    await saveManifest outFiles
            catch e
                console.error e
        }

        process.on 'beforeExit', =>
            saveManifest outFiles
            watcher.close()

        return

export default () => 
    program.hook 'preAction', () =>
        opts = { ...defaultOpts, ...program.opts<Options>() };
        ensureGitignoreManifestEntry();
    program.parse process.argv
