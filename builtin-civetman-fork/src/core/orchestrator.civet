// ──────────────────────────────────────────────────────────────
// Build orchestration layer – The conductor of the build process
// ──────────────────────────────────────────────────────────────

fs from "fs-extra"
glob from "fast-glob"
path from "node:path"
import type { Options, BuildContext } from "../support/config.civet"
import type { CompileResult } from "../types.civet"
import type { BuildEngine } from "./engine.civet"
import { BuildEngine as BuildEngineClass } from "./engine.civet"
import { getSourcePaths, toPosix, logDebug } from "../support/utils.civet"
import { loadCivetConfigContent } from "../support/config.civet"
import { loadPrevState, saveNewState, pruneStaleOutputs } from "./state.civet"
import { syncIDEConfigs } from "../support/integrations.civet"
import { cleanupTmpFiles } from "../support/fs.civet"
import { startBuildSpinner, logCompileResult, reportBuildResult } from "../cli/ui.civet"

// Top-level build function that orchestrates the entire build process
export orchestrateBuild := async (cwd: string, opts: Options, workerScriptPath: string, throwOnError: boolean = true): Promise<{ ctx: BuildContext, engine: BuildEngine, hadError: boolean }> =>
    // Step 0: scrub temp files from previous aborted runs
    await cleanupTmpFiles(cwd)

    // Step 1: collect source files
    { globPatterns } := getSourcePaths(opts, cwd)
    baseIgnores := ["node_modules/**", "dist/**", "**/*.civetmantmp", "**/.*"]
    userIgnores := (opts.ignoreFolders ?? []).map((d) => path.join(d, "**"))
    ignorePatterns := [...baseIgnores, ...userIgnores].map(toPosix)

    sources := await glob(globPatterns, ignore: ignorePatterns, cwd: cwd, caseSensitiveMatch: false)

    // Step 2: load previous state and create context
    // Load Civet config once and cache its parseOptions for the whole build run
    { configContent, parseOpts } := await loadCivetConfigContent(cwd)

    { prevGenerated, prevHashes } := await loadPrevState(cwd)
    ctx: BuildContext .=
        opts: opts,
        cwd: cwd,
        sources: sources,
        outFiles: new Set<string>(),
        prevGenerated: prevGenerated,
        prevHashes: prevHashes,
        newHashes: {},
        parseOpts: parseOpts,
        configContent: configContent

    // Create the build engine which orchestrates compilation.
    engine := new BuildEngineClass(ctx, workerScriptPath)

    // Step 3: build all, with progress reporting
    spinner := startBuildSpinner()
    
    // The engine does all the work and returns the results.
    results := await engine.buildAll()

    // Step 4: Process results, update state, and report to UI
    let hadError = false
    let builtCount = 0
    let skippedCount = 0

    for res of results
        if res.status == 'built'
            builtCount++
            ctx.outFiles.add(res.outFile)
            if opts.mapFiles and await fs.pathExists(res.outFile + ".map")
                ctx.outFiles.add(res.outFile + ".map")
            ctx.newHashes[res.file] = { sig: res.signature, outFile: res.outFile }
        else if res.status == 'skip'
            skippedCount++
            ctx.outFiles.add(res.outFile)
            ctx.newHashes[res.file] = { sig: res.signature, outFile: res.outFile }
        else if res.status == 'error'
            hadError = true
        logCompileResult(spinner, res)
    
    reportBuildResult(hadError, builtCount, skippedCount)

    // Step 5: prune stale outputs & save new state
    await pruneStaleOutputs(ctx)

    await saveNewState(ctx)

    // Step 6: IDE / VCS hygiene
    await syncIDEConfigs(ctx)

    if hadError and throwOnError
        // ensure worker threads are terminated so the process can exit cleanly
        if engine?
            await engine.pool.shutdown()
        throw new Error("Build failed with errors")

    // Make sure the returned context is up-to-date for watch mode
    ctx.prevGenerated = new Set([...ctx.outFiles])
    ctx.prevHashes = { ...ctx.prevHashes, ...ctx.newHashes }
    ctx.newHashes = {}

    return { ctx, engine, hadError }


// Type-check helper
export runTscTypeCheck := (cwd: string): Promise<void> =>
    new Promise (resolve, reject) =>
        child := require('node:child_process').spawn('npx', ['--yes', 'tsc', '-p', cwd, '--noEmit', '--pretty', 'false'], {
            cwd: cwd,
            stdio: 'inherit'
        })
        child.on 'close', (code: number) =>
            if code == 0 then resolve() else reject(new Error("tsc exit code " + code))

