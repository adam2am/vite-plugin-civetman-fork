import { describe, it, beforeEach, afterEach, beforeAll, expect } from 'vitest'
import fs from 'fs-extra'
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import { spawn, execSync } from 'node:child_process'

// __dirname polyfill for ESM
__filename := fileURLToPath(import.meta.url)
__dirname := path.dirname(__filename)

runBuild := (cwd: string, args: string[] = []): Promise<string> ->
  new Promise (resolve, reject) ->
      cliPath := path.resolve(__dirname, '..', '..', 'dist', 'cli', 'index.js')
      child := spawn('node', [cliPath, 'build', ...args], { cwd })
      output .= ''
      
      child.stdout?.on('data', (data) => output += data.toString())
      child.stderr?.on('data', (data) => output += data.toString())

      child.on 'error', reject
      child.on 'close', (code) ->
          if code == 0
              resolve(output)
          else
              reject(new Error(`Build failed with code ${code}. Output:\n${output}`))

describe 'Import Rewriter Integration Tests', ->
  testDir := path.join(__dirname, 'temp-import-test')
  
  beforeAll async ->
    // Ensure CLI is built before running integration tests
    cliPath := path.resolve(__dirname, '..', '..', 'dist', 'index.js')
    unless await fs.pathExists(cliPath)
      console.log('Building CLI for integration tests...')
      execSync('bun run build', { cwd: path.resolve(__dirname, '..', '..', '..') })
  
  beforeEach async ->
    // Clean up test directory
    if await fs.pathExists(testDir)
      await fs.remove(testDir)
    await fs.ensureDir(testDir)

  afterEach async ->
    // Clean up test directory with retries for Windows
    if await fs.pathExists(testDir)
      for attempt of [1..5]
        try 
          await fs.remove(testDir)
          break
        catch error
          if attempt is 5
            console.warn(`Failed to clean up test directory after ${attempt} attempts:`, error)
          else
            await new Promise((resolve) => setTimeout(resolve, 200 * attempt)) // Incremental backoff
    return


  it 'should rewrite .civet imports in compiled output', ->
    // Create test files
    testFile := path.join(testDir, 'test.civet')
    await fs.writeFile(testFile, `import { foo } from "./bar.civet"
import type { Baz } from "./types.civet"
import { external } from "some-package"

export const test = "hello"`)

    await runBuild(testDir, ['--out-ts', '.'])

    // Check the compiled output
    compiledFile := path.join(testDir, 'test.ts')
    expect(await fs.pathExists(compiledFile)).toBe(true)

    content := await fs.readFile(compiledFile, 'utf8')
    
    // Check that .civet extensions were removed
    expect(content.includes('from "./bar"')).toBe(true)
    expect(content.includes('from "./types"')).toBe(true)
    expect(!content.includes('.civet')).toBe(true)
    
    // Check that external imports are preserved
    expect(content.includes('from "some-package"')).toBe(true)

  it 'should preserve quote styles in imports', ->
    // Create test file with different quote styles
    testFile := path.join(testDir, 'quotes.civet')
    await fs.writeFile(testFile, `import { foo } from "./bar.civet"
import { baz } from './qux.civet'
import type { Type } from "./types.civet"`)

    await runBuild(testDir, ['--out-ts', '.'])

    // Check the compiled output
    content := await fs.readFile(path.join(testDir, 'quotes.ts'), 'utf8')
    
    // Check that quotes are preserved
    expect(content.includes('from "./bar"')).toBe(true)
    expect(content.includes("from './qux'")).toBe(true)
    expect(content.includes('from "./types"')).toBe(true)

  it 'should handle complex multi-line imports', ->
    // Create test file with complex imports
    testFile := path.join(testDir, 'complex.civet')
    await fs.writeFile(testFile, `import {
  foo,
  bar,
  type Baz
} from "./module.civet"

import type {
  Type1,
  Type2
} from "./types.civet"`)

    await runBuild(testDir, ['--out-ts', '.'])

    // Check the compiled output
    content := await fs.readFile(path.join(testDir, 'complex.ts'), 'utf8')
    
    // Check that multi-line imports are handled correctly
    expect(content.includes('from "./module"')).toBe(true)
    expect(content.includes('from "./types"')).toBe(true)
    expect(!content.includes('.civet')).toBe(true)

  it 'should not affect non-.civet imports', ->
    // Create test file with mixed imports
    testFile := path.join(testDir, 'mixed.civet')
    await fs.writeFile(testFile, `import { foo } from "./bar.civet"
import { baz } from "./qux.ts"
import { external } from "some-package"
import type { Type } from "./types.civet"`)

    await runBuild(testDir, ['--out-ts', '.'])

    // Check the compiled output
    content := await fs.readFile(path.join(testDir, 'mixed.ts'), 'utf8')
    
    // Check that only .civet imports were modified
    expect(content.includes('from "./bar"')).toBe(true)
    expect(content.includes('from "./qux"')).toBe(true) // Civet compiler is now stripping .ts extension
    expect(content.includes('from "some-package"')).toBe(true)
    expect(content.includes('from "./types"')).toBe(true)

  it 'should handle side-effect imports', ->
    // Create test file with side-effect imports
    testFile := path.join(testDir, 'side-effect.civet')
    await fs.writeFile(testFile, `import "./styles.civet"
import "./utils.civet"
import "external-package"`)

    await runBuild(testDir, ['--out-ts', '.'])

    // Check the compiled output
    content := await fs.readFile(path.join(testDir, 'side-effect.ts'), 'utf8')
    
    // Check that side-effect imports are handled
    expect(content.includes('import "./styles"')).toBe(true)
    expect(content.includes('import "./utils"')).toBe(true)
    expect(content.includes('import "external-package"')).toBe(true)
