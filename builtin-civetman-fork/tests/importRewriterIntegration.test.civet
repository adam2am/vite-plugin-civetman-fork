import { describe, it, beforeEach, afterEach, expect } from 'vitest'
import fs from 'fs-extra'
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import { execSync } from 'child_process'

// __dirname polyfill for ESM
__filename := fileURLToPath(import.meta.url)
__dirname := path.dirname(__filename)

describe 'Import Rewriter Integration Tests', ->
  testDir := path.join(__dirname, 'temp-import-test')
  
  beforeEach async ->
    // Clean up test directory
    if await fs.pathExists(testDir)
      await fs.remove(testDir)
    await fs.ensureDir(testDir)

  afterEach async ->
    // Clean up test directory with retries for Windows
    if await fs.pathExists(testDir)
      for attempt of [1..3]
        try 
          await fs.remove(testDir)
          break
        catch error
          if attempt is 3
            console.warn('Failed to clean up test directory after 3 attempts:', error)
          else
            await new Promise((resolve) => setTimeout(resolve, 100))
    return

  it 'should rewrite .civet imports in compiled output', ->
    // Create test files
    testFile := path.join(testDir, 'test.civet')
    await fs.writeFile(testFile, `import { foo } from "./bar.civet"
import type { Baz } from "./types.civet"
import { external } from "some-package"

export const test = "hello"`)

    // Run civetman build
    try
      execSync(`bun ../../dist/index.js build --out-ts .`, { 
        cwd: testDir,
        stdio: 'pipe'
      })
    catch error
      console.error('Build failed:', (error as Error).message)
      throw error

    // Check the compiled output
    compiledFile := path.join(testDir, 'test.ts')
    expect(await fs.pathExists(compiledFile)).toBe(true)

    content := await fs.readFile(compiledFile, 'utf8')
    
    // Check that .civet extensions were removed
    expect(content.includes('from "./bar"')).toBe(true)
    expect(content.includes('from "./types"')).toBe(true)
    expect(!content.includes('.civet')).toBe(true)
    
    // Check that external imports are preserved
    expect(content.includes('from "some-package"')).toBe(true)

  it 'should preserve quote styles in imports', ->
    // Create test file with different quote styles
    testFile := path.join(testDir, 'quotes.civet')
    await fs.writeFile(testFile, `import { foo } from "./bar.civet"
import { baz } from './qux.civet'
import type { Type } from "./types.civet"`)

    // Run civetman build
    execSync(`bun ../../dist/index.js build --out-ts .`, { 
      cwd: testDir,
      stdio: 'pipe'
    })

    // Check the compiled output
    content := await fs.readFile(path.join(testDir, 'quotes.ts'), 'utf8')
    
    // Check that quotes are preserved
    expect(content.includes('from "./bar"')).toBe(true)
    expect(content.includes("from './qux'")).toBe(true)
    expect(content.includes('from "./types"')).toBe(true)

  it 'should handle complex multi-line imports', ->
    // Create test file with complex imports
    testFile := path.join(testDir, 'complex.civet')
    await fs.writeFile(testFile, `import {
  foo,
  bar,
  type Baz
} from "./module.civet"

import type {
  Type1,
  Type2
} from "./types.civet"`)

    // Run civetman build
    execSync(`bun ../../dist/index.js build --out-ts .`, { 
      cwd: testDir,
      stdio: 'pipe'
    })

    // Check the compiled output
    content := await fs.readFile(path.join(testDir, 'complex.ts'), 'utf8')
    
    // Check that multi-line imports are handled correctly
    expect(content.includes('from "./module"')).toBe(true)
    expect(content.includes('from "./types"')).toBe(true)
    expect(!content.includes('.civet')).toBe(true)

  it 'should not affect non-.civet imports', ->
    // Create test file with mixed imports
    testFile := path.join(testDir, 'mixed.civet')
    await fs.writeFile(testFile, `import { foo } from "./bar.civet"
import { baz } from "./qux.ts"
import { external } from "some-package"
import type { Type } from "./types.civet"`)

    // Run civetman build
    execSync(`bun ../../dist/index.js build --out-ts .`, { 
      cwd: testDir,
      stdio: 'pipe'
    })

    // Check the compiled output
    content := await fs.readFile(path.join(testDir, 'mixed.ts'), 'utf8')
    
    // Check that only .civet imports were modified
    expect(content.includes('from "./bar"')).toBe(true)
    expect(content.includes('from "./qux.ts"')).toBe(true)
    expect(content.includes('from "some-package"')).toBe(true)
    expect(content.includes('from "./types"')).toBe(true)

  it 'should handle side-effect imports', ->
    // Create test file with side-effect imports
    testFile := path.join(testDir, 'side-effect.civet')
    await fs.writeFile(testFile, `import "./styles.civet"
import "./utils.civet"
import "external-package"`)

    // Run civetman build
    execSync(`bun ../../dist/index.js build --out-ts .`, { 
      cwd: testDir,
      stdio: 'pipe'
    })

    // Check the compiled output
    content := await fs.readFile(path.join(testDir, 'side-effect.ts'), 'utf8')
    
    // Check that side-effect imports are handled
    expect(content.includes('import "./styles"')).toBe(true)
    expect(content.includes('import "./utils"')).toBe(true)
    expect(content.includes('import "external-package"')).toBe(true)
