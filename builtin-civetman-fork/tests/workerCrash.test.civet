import { describe, it, expect } from 'vitest'
import fs from 'fs-extra'
import os from 'node:os'
import path from 'node:path'
import { WorkerPool } from '../src/worker/pool.civet'
import { fileURLToPath } from 'node:url'

// ESM __dirname polyfill
__filename := fileURLToPath(import.meta.url)
__dirname := path.dirname(__filename)

// Generates a temporary Civet file with the given content
makeTempFile := async (dir: string, name: string, content: string) ->
    filePath := path.join(dir, name)
    await fs.writeFile(filePath, content)
    return filePath

// Resolve compiled worker script path from dist (no copying into src)
resolveWorkerPath := async () ->
    // Prefer top-level dist/cli/workers for package run
    candidate := path.join(__dirname, '..', '..', 'dist', 'cli', 'workers', 'compileWorker.cjs')
    if await fs.pathExists(candidate) then candidate else candidate

describe "WorkerPool â€“ crash recovery", () =>
    it "should still compile after a worker exits abnormally", async ->
        tmpDir := await fs.mkdtemp(path.join(os.tmpdir(), 'civetman-crash-'))

        // Prepare two small civet sources
        file1 := await makeTempFile(tmpDir, 'one.civet', 'a: number := 1\nexport {}')
        file2 := await makeTempFile(tmpDir, 'two.civet', 'b: number := 2\nexport {}')

        workerScriptPath := await resolveWorkerPath()
        pool := new WorkerPool(workerScriptPath, 1)

        // First compile should succeed
        res1 := await pool.exec({ file: file1, content: 'a: number := 1\nexport {}', isTsx: false, wantMap: false })
        expect(res1.ok).toBe(true)
        if res1.ok
            expect(res1.code.includes('const a:')).toBe(true)

        // Simulate a worker crash by force-terminating the thread
        if pool.idle.length == 0
            throw new Error('No idle worker available to crash')
        crashed := pool.idle[0]
        await crashed.terminate()
        // Manually remove from idle list to mimic non-zero exit handling
        pool.idle = pool.idle.filter((w) => w !== crashed)

        // Verify pool has no idle workers left
        expect(pool.idle.length).toBe(0)

        // The next compile should spawn a fresh worker and succeed
        let res2: any
        try {
            res2 = await pool.exec({ file: file2, content: 'b: number := 2\nexport {}', isTsx: false, wantMap: false })
        } catch (e) {
            console.error("Second compilation failed after worker crash:", e)
            // Force failure with the actual error logged above
            expect(e).toBe(undefined)
        }

        expect(res2.ok).toBe(true)
        if res2.ok
            expect(res2.code.includes('const b:')).toBe(true)

        // Clean up: terminate any remaining workers so test can exit cleanly
        await Promise.all(pool.idle.map((w) => w.terminate()))
    , 15000 // timeout

// Nothing to prepare eagerly anymore; worker path is resolved at runtime