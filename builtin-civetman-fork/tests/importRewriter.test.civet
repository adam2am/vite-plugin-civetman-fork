import { describe, it, expect } from 'vitest'
import { rewriteCivetImports, findAllImports } from '../src/import-rewriter.civet'

describe 'Import Rewriter', () ->
  describe 'findAllImports', () ->
    it 'should find single-line imports with .civet', ->
      ext := '.civet'
      code := `import { foo } from "./module${ext}";`
      imports := findAllImports(code)
      expect(imports).toHaveLength(1)
      expect(imports[0].spec).toBe("./module.civet")
      expect(imports[0].type).toBe("from")

    it 'should find multi-line imports', ->
      code := `import {
        foo,
        bar
      } from './module'`
      imports := findAllImports(code) 
      expect(imports).toHaveLength(1)
      expect(imports[0].spec).toBe('./module')

    it 'should find type-only imports', ->
      ext := '.civet'
      code := `import type { Foo } from "./types${ext}";`
      imports := findAllImports(code)
      expect(imports).toHaveLength(1)
      expect(imports[0].spec).toBe("./types.civet")

    it 'should handle single quotes', ->
      ext := '.civet'
      code := `import { foo } from './module${ext}';`
      imports := findAllImports(code)
      expect(imports).toHaveLength(1)
      expect(imports[0].spec).toBe("./module.civet")

    it 'should handle unquoted imports', ->
      code := "import { foo } from ./module" // Civet would likely fail to compile this, but as a unit test...
      imports := findAllImports(code)
      expect(imports.length).toBe(0)

    it 'should ignore non-.civet imports', ->
      code := 'import { foo } from "./module.ts"\nimport { bar } from "external"'
      imports := findAllImports(code) 
      expect(imports).toHaveLength(2)
      expect(imports[0].spec).toBe("./module.ts")
      expect(imports[1].spec).toBe("external")

    it 'should handle side-effect imports', ->
      ext := '.civet'
      code := `import "./module${ext}";`
      imports := findAllImports(code)
      expect(imports).toHaveLength(1)
      expect(imports[0].spec).toBe("./module.civet")
      expect(imports[0].type).toBe("side-effect")

  describe 'rewriteCivetImports', () ->
    it 'should rewrite single .civet import', ->
      ext := '.civet'
      input := `import { foo } from "./module${ext}"`
      result := rewriteCivetImports(input)
      expect(result).toBe('import { foo } from "./module"')

    it 'should rewrite multiple .civet imports', ->
      ext := '.civet'
      input := `import { foo } from "./module${ext}"
import { bar } from "./other${ext}"`
      result := rewriteCivetImports(input)
      expected := `import { foo } from "./module"
import { bar } from "./other"`
      expect(result).toBe(expected)

    it 'should preserve single quotes', ->
      ext := '.civet'
      input := `import { foo } from './module${ext}'`
      result := rewriteCivetImports(input)
      expect(result).toBe("import { foo } from './module'")

    it 'should not rewrite unquoted import specifiers', ->
      ext := '.civet'
      input := `import { foo } from ./module${ext}`
      result := rewriteCivetImports(input)
      // The rewriter should only target quoted strings. It correctly ignores
      // unquoted specifiers, so the input should be returned unchanged.
      expect(result).toBe(input)

    it 'should not touch non-.civet imports', ->
      ext := '.civet'
      input := `import { foo } from "./module.ts"
import { bar } from "external"
import { baz } from "./module${ext}"`
      result := rewriteCivetImports(input)
      expected := `import { foo } from "./module.ts"
import { bar } from "external"
import { baz } from "./module"`
      expect(result).toBe(expected)

    it 'should handle mixed import types', ->
      ext := '.civet'
      input := `import type { Foo } from "./types${ext}"
import { bar } from "./module${ext}"
import "./side-effect${ext}"`
      result := rewriteCivetImports(input)
      expected := `import type { Foo } from "./types"
import { bar } from "./module"
import "./side-effect"`
      expect(result).toBe(expected)

    it 'should handle complex multi-line imports', ->
      ext := '.civet'
      input := `import {
        foo,
        bar,
        type Baz
      } from "./complex${ext}"`
      result := rewriteCivetImports(input)
      expected := `import {
        foo,
        bar,
        type Baz
      } from "./complex"`
      expect(result).toBe(expected)

    it 'should handle relative paths with ../', ->
      ext := '.civet'
      input := `import { foo } from "../parent/module${ext}"`
      result := rewriteCivetImports(input)
      expect(result).toBe('import { foo } from "../parent/module"')

    it 'should handle absolute paths', ->
      ext := '.civet'
      input := `import { foo } from "/absolute/path/module${ext}"`
      result := rewriteCivetImports(input)
      expect(result).toBe('import { foo } from "/absolute/path/module"')

    it 'should return unchanged code when no .civet imports', ->
      input := `import { foo } from "./module.ts"
import { bar } from "external"`
      result := rewriteCivetImports(input)
      expect(result).toBe(input)

    it 'should handle empty string', ->
      result := rewriteCivetImports("")
      expect(result).toBe("")

    it 'should handle code without imports', ->
      input := `const foo = "bar"
console.log(foo)`
      result := rewriteCivetImports(input)
      expect(result).toBe(input)

    it 'should handle nested .civet in path', ->
      ext := '.civet'
      input := `import { foo } from "./civet-folder/module${ext}"`
      result := rewriteCivetImports(input)
      expect(result).toBe('import { foo } from "./civet-folder/module"')

    it 'should not affect .civet in middle of path', ->
      ext := '.civet'
      input := `import { foo } from "./civet-folder${ext}/module.ts"`
      result := rewriteCivetImports(input)
      expect(result).toBe('import { foo } from "./civet-folder.civet/module.ts"')
    return
  return