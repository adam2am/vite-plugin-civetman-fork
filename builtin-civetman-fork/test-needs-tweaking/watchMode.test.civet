import { describe, it, beforeAll, afterAll, expect } from 'vitest'
import { spawn, ChildProcess } from 'node:child_process'
import fs from 'fs-extra'
import path from 'node:path'
import { fileURLToPath } from 'node:url'

stripAnsi := (str: string) => str.replace(/\u001b\[[0-9;]*m/g, '')

// ESM replacements for __filename / __dirname
__filename := fileURLToPath(import.meta.url)
__dirname  := path.dirname(__filename)

// Robust cleanup helper for Windows
robustCleanup := async (dir: string) ->
    if await fs.pathExists(dir)
        for attempt of [1..5]
            try 
                await fs.remove(dir)
                break
            catch error
                if attempt is 5
                    console.warn(`Failed to clean up directory after ${attempt} attempts:`, error)
                else
                    await new Promise((resolve) => setTimeout(resolve, 200 * attempt)) // Incremental backoff

// Accumulate watcher output – makes it trivial to check for substrings later.
outputBuffer .= ""
appendOutput := (chunk: unknown) ->
    outputBuffer += stripAnsi(String(chunk))

// Utility: wait until a specific text appears in watcher output (or fail after timeout)
waitFor := (text: string, timeout = 10000) ->
    new Promise (resolve, reject) ->
        if outputBuffer.includes(text)
            return resolve(true)
        start := Date.now()
        check := ->
            if outputBuffer.includes(text)
                return resolve(true)
            if (Date.now() - start) > timeout
                return reject new Error("Timeout waiting for: " + text)
            setTimeout(check, 50)
        check()

describe "Civetman Watch – basic rebuild", ->
    watcher: ChildProcess | null .= null
    testDir := path.resolve(__dirname, "temp-watch-test")
    fixtureDir := path.resolve(__dirname, "..", "tests", "fixture")
    civetPath := path.join(testDir, "dummy.civet")
    tsPath    := path.join(testDir, "dummy.ts")

    beforeAll async ->
        // Prepare clean test folder
        await robustCleanup(testDir)
        await fs.copy(fixtureDir, testDir)

        // Ensure CLI is built (dist/cli/index.js)
        cli := path.resolve(__dirname, '..', '..', 'dist', 'cli', 'index.js')
        unless await fs.pathExists(cli)
            throw new Error("Civetman CLI not built – run pnpm run build before tests")

        // Start watcher process
        watcher = spawn('node', [cli, 'dev'], { 
            cwd: testDir, 
            shell: process.platform === 'win32',
            env: { ...process.env, CIVETMAN_DEBUG: '*' }
        })
        watcher.stdout?.on('data', appendOutput)
        watcher.stderr?.on('data', appendOutput)

        // Wait until watcher is ready
        await waitFor("Watching for changes")

    afterAll async ->
        if watcher
            // On Windows, a simple kill() isn't enough. We need to be more forceful
            // and ensure we wait for the process to actually exit.
            if watcher.stdout then watcher.stdout.destroy()
            if watcher.stderr then watcher.stderr.destroy()
            
            watcher.kill('SIGKILL') // Use a more forceful signal
            
            await new Promise((resolve) => watcher!.on('close', resolve))
            watcher = null

        await new Promise((resolve) => setTimeout(resolve, 500)) // Extra pause before cleanup
        await robustCleanup(testDir)

    it("should build initially and after a change", async ->
        // 1) Initial build verification
        content1 := await fs.readFile(tsPath, 'utf8')
        expect(content1.includes("const a: number = 1")).toBe(true)

        // 2) Trigger a change
        await fs.writeFile(civetPath, "a: number := 2\nexport {}")
        await waitFor("✓ dummy.civet -> dummy.ts", 15000)

        // 3) Confirm rebuild output
        content2 := await fs.readFile(tsPath, 'utf8')
        expect(content2.includes("const a: number = 2")).toBe(true)
    , 25000) // Increased timeout for slow CI